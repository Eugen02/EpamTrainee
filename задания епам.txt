Project task-jtu-practice1


Практическое задание №1
_______________________


Задание 1
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice1.Part1
-------------------------------------------------------

Написать класс, который реализует функциональность вывода в консоль строки "Hello, World". 
Написать командный файл (bat файл Windows или shell скрипт Linux), который компилирует и запускает данное приложение из консоли. 
Командный файл сохранить в каталоге src проекта.

_______________________

Задание 2
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice1.Part2
-------------------------------------------------------

Написать класс, который реализует функциональность сложения чисел, переданных в приложение как параметры командной строки.

_______________________

Задание 3
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice1.Part3
-------------------------------------------------------

Написать класс, который реализует функциональность вывода параметров командной строки в консоль (выводить через пробел), вывод не должен заканчиваться пробелом.

_______________________

Задание 4
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice1.Part4
-------------------------------------------------------

Написать класс, который реализует функциональность определения наибольшего общего делителя двух целых положительных чисел, переданных в приложение как параметры командной строки.

_______________________

Задание 5
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice1.Part5
-------------------------------------------------------

Написать класс, который реализует функциональность определения суммы цифр целого положительного числа, переданного в приложение как параметр командной строки.

_______________________

Задание 6
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice1.Part6
-------------------------------------------------------

Написать класс, который создает массив из n элементов и заполняет его восходящим рядом простых чисел (2, 3, 5, 7, ...). Число n передавать как параметр командной строки

_______________________

Задание 7
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice1.Part7
-------------------------------------------------------

Колонки электронных таблиц (например Excel) имеют буквенную нумерацию в виде больших букв латинского алфавита (последовательно, слева направо):
A, B, ..., Y, Z, AA, AB, ..., AY, AZ, BA, BB, ... и т.д.

В то же время каждая колонка имеет порядковый номер: A - 1; B - 2; ... ; Y - 25; Z - 26; AA - 27; AB - 28; ... и т.д. 

Написать класс, который содержит следующие три метода:

1) метод определения порядкового номера колонки по ее буквенному номеру
[ public static int str2int(String number): A => 1; B => 2; ...; Z => 26; AA => 27; AB => 28; ... ];

2) метод определения буквенного номера колонки по ее порядковому номеру
[ public static String int2str(int number): 1 => A; 2 => B; ...; 26 => Z; 27 ==> AA; 28 ==> AB; ... ];

3) метод определения по буквенному номеру колонки номер колонки, которая находится справа от данной
[ public static String rightColumn(String number): A => B; B => C; ...; Y => Z; Z => AA; AA => AB; ...].

Работу методов проверить на следующих данных

-------------------------------------------------------
A ==> 1 ==> A
B ==> 2 ==> B
Z ==> 26 ==> Z
AA ==> 27 ==> AA
AZ ==> 52 ==> AZ
BA ==> 53 ==> BA
ZZ ==> 702 ==> ZZ
AAA ==> 703 ==> AAA
-------------------------------------------------------

_______________________

Замечания.
1. Результат должен быть представлен в виде проекта с именем Practice1.
2. Корневой пакет для всех классов и прочих пакетов (если они потребуются): ua.nure.your_last_name.practice1, где your_last_name - ваш логин без кода проекта.
Если логин=ivanovjtp, то your_last_name=ivanov
3. Дополнительно в корневой пакет положить класс Demo, который демонстриует работу всех 7 подзадач.
4. Проект загрузить в репозиторий, проверить, успешность сборки в Jenkins, оптимизировать метрики в Sonar (после того, как будет дан доступ к этим системам).

_______________________

Вопросы.
1. Какие категории типов данных существуют в Java?
2. Перечислите примитивные типы данных. 
3. Тип данных char, что хранит, область определения.
4. Напишите метод main (два варианта).
5. Укажите автоматические преобразования между примитивными типами
6. При каких преобразованиях между примитивными типами возможна утрата информации?
7. Какие преобразования между типами вы знаете.
8. Что такое wrappers, autoboxing, autounboxing.
9. Напишите анонимный массив, массив константу, в чем отличие.
10. Напишите пример двумерного массива.



Практическое занятие №2
_______________________

Замечание. Запрещено использовать любые типы из пакета java.util, кроме двух:
1) java.util.Iterator
2) java.util.NoSuchElementException

_______________________

Создать и расположить в корневом пакете (ua.nure.your_last_name.practice2) интерфейс Container:

-----------------------------
package ua.nure.your_last_name.practice2;

public interface Container extends Iterable<Object> {
	
	// Removes all of the elements.
	void clear();

	// Returns the number of elements.
	int size();
	
	// Returns a string representation of this container.
	String toString();

	// Returns an iterator over elements.
	// Iterator must implements the remove method.
	Iterator<Object> iterator();

}
-----------------------------

_______________________

Задание 1
-------------------------------------------------------
Имена типов: Array, ArrayImpl
-------------------------------------------------------

1.1. Создать интерфейс Array следующего содержания:

-----------------------------
package ua.nure.your_last_name.practice2;

public interface Array extends Container {

	// Add the specified element to the end.
	void add(Object element);

	// Sets the element at the specified position.
	void set(int index, Object element);

	// Returns the element at the specified position.
	Object get(int index);

	// Returns the index of the first occurrence of the specified element,
	// or -1 if this array does not contain the element.
	// (use 'equals' method to check an occurrence)
	int indexOf(Object element);

	// Removes the element at the specified position.
	void remove(int index);

}
-----------------------------

1.2. Создать класс ArrayImpl, который реализует интерфейс Array.

Хранение объектов внутри контейнера реализовать с помощью массива объектов.

Метод iterator должен возвращать экземпляр класса IteratorImpl, который реализует интерфейс java.util.Iterator<Object>.
Класс IteratorImpl должен быть определен внутри класса ArrayImpl (является внутренним классом).

Если в контейнер были добавлены с помощью метода add три элемента A, B, C, то:
1) метод toString должен возвращать строку "[A, B, C]"
2) порядок обхода элементов контейнера итератором: A B C

1.3. В классе ArrayImpl создать метод main, в котором продемонстрировать работу:
1) всех методов интерфейса Array (включая унаследованные от Container и Iterable);
2) всех методов интерфейса Iterator (hasNext/next/remove).

_______________________

Задание 2
-------------------------------------------------------
Имя пакета: ua.nure.your_last_name.practice2
Имена типов: List, ListImpl
-------------------------------------------------------

2.1. Создать интерфейс List следующего содержания:

-----------------------------
package ua.nure.your_last_name.practice2

public interface List extends Container {

	// Inserts the specified element at the beginning.
	void addFirst(Object element);

	// Appends the specified element to the end.
	void addLast(Object element);

	// Removes the first element.
	void removeFirst();

	// Removes the last element.
	void removeLast();

	// Returns the first element.
	Object getFirst();

	// Returns the last element.
	Object getLast();

	// Returns the first occurrence of the specified element.
	// Returns null if no such element.
	// (use 'equals' method to check an occurrence)
	Object search(Object element);

	// Removes the first occurrence of the specified element.
	// Returns true if this list contained the specified element. 
	// (use 'equals' method to check an occurrence)
	boolean remove(Object element);

}
-----------------------------

2.2. Создать класс ListImpl, который реализует интерфейс List.

Хранение объектов внутри контейнера реализовать с помощью совокупности узлов - экземпляров класса Node.
Каждый узел хранит объект и ссылку на следующий узел.
Класс Node должен быть определен внутри класса ListImpl (является вложенным static классом).

Метод iterator должен возвращать экземпляр класса IteratorImpl, который реализует интерфейс java.util.Iterator<Object>.
Класс IteratorImpl должен быть определен внутри класса ListImpl (является внутренним классом).

Если в контейнер были добавлены с помощью метода addLast три элемента A, B, C, то:
1) метод toString должен возвращать строку "[A, B, C]"
2) порядок обхода элементов контейнера итератором: A B C

2.3. В классе ListImpl создать метод main, в котором продемонстрировать работу:
1) всех методов интерфейса List (включая унаследованные от Container и Iterable);
2) всех методов интерфейса Iterator (hasNext/next/remove).
_______________________

Задание 3
-------------------------------------------------------
Имена типов: Queue, QueueImpl
-------------------------------------------------------

3.1. Создать интерфейс Queue следующего содержания:

-----------------------------
package ua.nure.your_last_name.practice2;

public interface Queue extends Container {

	// Appends the specified element to the end.
	void enqueue(Object element);

	// Removes the head.
	Object dequeue();

	// Returns the head.
	Object top();

}
-----------------------------

3.2. Создать класс QueueImpl, который реализует интерфейс Queue.

Если в контейнер были добавлены три элемента A, B, C с помощью метода enqueue

1) метод toString должен возвращать строку "[A, B, C]"
2) порядок обхода элементов контейнера итератором: A B C

3.3. В классе QueueImpl создать метод main, в котором продемонстрировать работу:
1) всех методов интерфейса Queue (включая унаследованные от Container и Iterable);
2) всех методов интерфейса Iterator (hasNext/next/remove).

_______________________

Задание 4
-------------------------------------------------------
Имена типов: Stack, StackImpl
-------------------------------------------------------

4.1. Создать интерфейс Stack следующего содержания:

-----------------------------
package ua.nure.your_last_name.practice2;

public interface Stack extends Container {
	
	// Pushes the specified element onto the top.
	void push(Object element);
	
	// Removes and returns the top element.
	Object pop();

	// Returns the top element.
	Object top();
	
}
-----------------------------

4.2. Создать класс StackImpl, который реализует интерфейс Stack.

Если в контейнер были добавлены с помощью метода push три элемента A, B, C, то:
1) метод toString должен возвращать строку "[A, B, C]"
2) порядок обхода элементов контейнера итератором: C B A

4.3. В классе StackImpl создать метод main, в котором продемонстрировать работу:
1) всех методов интерфейса Stack (включая унаследованные от Container и Iterable);
2) всех методов интерфейса Iterator (hasNext/next/remove).

_______________________

Замечания.
1. Результат должен быть представлен в виде проекта с именем Practice2.
2. Корневой пакет для всех классов: ua.nure.your_last_name.practice2
3. Дополнительно в корневом пакете расположить класс Demo, который демонстриует работу всех подзадач.
4. Проект загрузить в репозиторий, проверить успешность сборки в Jenkins, оптимизировать метрики в Sonar.

_______________________

Вопросы.
1. Что такое перекрытие, перегрузка, сокрытие метода.
2. Что такое наследование, ключевые слова implements, extends.
3. Какие типы не могут быть наследованы?
4. Ограничения при перекрытии метода.
5. Что такое инкапсуляция, для чего она предназначена, как ее реализовать.
6. Контексты использования ключевого слова final.
7. Порядок вызова конструкторов, блоков инициализации при создании объекта.
8. Анонимные классы.
9. В чем отличие вложенных классов от внутренних.


Практическое занятие №3
_______________________

***********************
ВНИМАНИЕ!
(1) указаны имена классов и методов
(3) указаны имена файлов со входной информацией;
(4) всюду, где не оговорено специально, во входной информации может быть кириллица (буквы русского и украинского языков);
***********************

Замечание.
Если приложение считывает информацию из файла, то необходимо указать кодировку, в которой она (информация) записана.
Использовать кодировку Cp1251, cм. пример "Как получить входную информацию" в конце текста.
Каждый класс PartX должен иметь метод main, который демонстрирует работу соответствующей подзадачи.
В корневом пакете создать класс Demo, который демонстрирует работу всего написанного функционала.

_______________________

Задание 1
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice3.Part1
Входную информацию загружать из файла part1.txt
-------------------------------------------------------

Задание должно быть решено с помощью регулярных выражений без использования контейнерных классов.

Определить класс со статическими методами, которые преобразовывают входную информацию в выходную.
В качестве входной информации (input data) использовать текст следующей структуры (значения Login/Name/Email в общем случае могут быть любыми; Login и Name могут содержать латиницу и кириллицу):

Input data (part1.txt)
-------------------------------------------------------
Login;Name;Email
ivanov;Ivan Ivanov;ivanov@mail.com
петров;Петр Петров;petrov@google.com
obama;Barack Obama;obama@google.com
bush;Джордж Буш;bush@mail.com
-------------------------------------------------------

Методы, которые нужно написать, имеют следующий вид (N - цифра: 1, 2, 3, 4):

-------------------------------------------------------
public static String convertN(String input) {
    ...
}
-------------------------------------------------------

1.1. Метод convert1
Должен преобразовывать input data в строку следующего вида:

Output of convert1
-------------------------------------------------------
ivanov: ivanov@mail.com
петров: petrov@google.com
obama: obama@google.com
bush: bush@mail.com
-------------------------------------------------------

1.2. Метод convert2
Должен преобразовывать input data в строку следующего вида:

Output of convert2
-------------------------------------------------------
Ivanov Ivan (email: ivanov@mail.com)
Петров Петр (email: petrov@google.com)
Obama Barack (email: obama@google.com)
Буш Джордж (email: bush@mail.com)
-------------------------------------------------------

1.3. Метод convert3
Должен преобразовывать input data в строку следующего вида (почтовый домен ==> список логинов через запятую тех пользователей, чьи почтовые ящики зарегестрированны в данном домене):

Output of convert3
-------------------------------------------------------
mail.com ==> ivanov, bush
google.com ==> петров, obama
-------------------------------------------------------

1.4. Метод convert4
Должен преобразовывать input data в строку следующего вида (должна быть добавлена колонка Password, сам пароль должен состоять ровно из 4 цифр, которые генерируются случайным образом):

Output of convert4
-------------------------------------------------------
Login;Name;Email;Password
ivanov;Ivan Ivanov;ivanov@mail.com;1707
петров;Петр Петров;petrov@google.com;9321
obama;Barack Obama;obama@google.com;4623
bush;Джордж Буш;bush@mail.com;7514
-------------------------------------------------------

_______________________

Задание 2
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice3.Part2
Входную информацию загружать из файла part2.txt
-------------------------------------------------------

Задание должно быть решено с помощью регулярных выражений без использования контейнерных классов.

Вход: текст (может состоять из латиницы и кириллицы).
Выход: слова максимальной и минимальной длины в формате, который дан ниже (в единственном числе, в порядке их появления в тексте, с учетом регистра символов).
Словом считать последовательность содержащую только буквы.

Создать статический метод convert, который преобразовывает вход в выход.

Заглушка метода
-------------------------------------------------------
public static String convert(String input) {
    ...
}
-------------------------------------------------------

Пример Input data (part2.txt)
-------------------------------------------------------
When I was younger, so much younger than today
I never needed anybody's help in any way
But now these days are gone, I'm not so self-assured
Now I find I've changed my mind
I've opened up the doors
-------------------------------------------------------

Пример Output
-------------------------------------------------------
Min: I, s, m
Max: younger, anybody, assured, changed
-------------------------------------------------------

_______________________

Задание 3
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice3.Part3
Входную информацию загружать из файла part3.txt
-------------------------------------------------------

Задание должно быть решено с помощью регулярных выражений без использования контейнерных классов.

Вход: текст (может состоять из латиницы и кириллицы).
Выход: исходный текст, но регистр первого символа каждого слова, которое состоит из трех и более символов, должен быть интвертирован.

Словом считать последовательность содержащую только буквы (все остальные символы в состав слова не входят).
Создать статический метод convert, который преобразовывает вход в выход.

Заглушка метода
-------------------------------------------------------
public static String convert(String input) {
    ...
}
-------------------------------------------------------

Пример Input data
-------------------------------------------------------
When I was younger
I never needed
-------------------------------------------------------

Пример Output
-------------------------------------------------------
when I Was Younger
I Never Needed
-------------------------------------------------------

_______________________

Задание 4
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice3.Part4
-------------------------------------------------------

Для хеширования информации (например, паролей) используют метод MessageDigest#digest, который возвращает хеш в виде массива байт.

Пример хеширования пароля с помощью алгоритма хеширования MD5 (другие алгоритмы - SHA-256; SHA-512 и пр.)
-------------------------------------------------------
import java.security.*;
import java.util.Arrays;
 
public class HashExample {      
    public static void main(String[] args) 
            throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance("MD5");
        digest.update("password to hash".getBytes());
        byte[] hash = digest.digest();
        System.out.println(Arrays.toString(hash));
        // output: [56, 55, 83, 50, 113, -114, -54, 115, -125, 86, 79, -109, 17, -65, 107, 84]
    }   
}
-------------------------------------------------------

Написать статический метод hash, который на вход принимает два параметра: 
(1) строку, хеш которой нужно получить; 
(2) названия алгоритма хеширования.

Выход  должен представлять из себя строку из шестнадцатеричных цифр: 
каждому байту соответствует две шестнадцатеричные цифры. 

Например, если некоторый элемент массива байт равен -29, то в двоичном разложении он имеет вид 1110_0011 и ему соответствует пара E3.

Заглушка класса Part4
-------------------------------------------------------
package ua.nure.your_last_name.practice3.Part4;

import java.security.*;
 
public class Part4 {
    public static String hash(String input, String algorithm) throws NoSuchAlgorithmException {
        // place yhour code here
        return null;
    }
    public static void main(String[] args) throws NoSuchAlgorithmException {
        System.out.println(hash("password", "SHA-256"));
        System.out.println(hash("passwort", "SHA-256"));
    }
}
-------------------------------------------------------


Если код метода Part4.main такой:
-------------------------------------------------------
System.out.println(hash("asdf", "MD5"));
System.out.println(hash("asdf", "SHA-256"));
-------------------------------------------------------

то результат должен быть таким:
-------------------------------------------------------
912EC803B2CE49E4A541068D495AB570
F0E4C2F76C58916EC258F246851BEA091D14D4247A2FC3E18694461B1816E13B
-------------------------------------------------------


_______________________

Задание 5
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice3.Part5
-------------------------------------------------------

Создать класс с двумя статическими методами перевода из десятичной системы счисления в римскую и обратно.

-------------------------------------------------------
public static String decimal2Roman(int x) { ... }
public static int roman2Decimal(String s) { ... }
-------------------------------------------------------

Рабочий диапазон методов - от 1 до 100 включительно.
Контейнерные классы не использовать.

Работу методов продемонстрировать так: 

DECIMAL -decimal2Roman-> ROMAN -roman2Decimal-> DECIMAL
-------------------------------------------------------
1 --> I --> 1
2 --> II --> 2
3 --> III --> 3
4 --> IV --> 4
5 --> V --> 5
...
94 --> XCIV --> 94
95 --> XCV --> 95
96 --> XCVI --> 96
97 --> XCVII --> 97
98 --> XCVIII --> 98
99 --> XCIX --> 99
100 --> C --> 100
-------------------------------------------------------
	
Продумать алгоритм и запрограммировать.

Брут-форс (полный перебор) не допускается! 
Решение, которое использует массив (контейнер) из ста элементов, из рассмотрения исключить:

-------------------------------------------------------
String[] numbers = {"I", "II", "III", "IV", "V", ..., "XCV", "XCVI", "XCVII", ..., "C"}
-------------------------------------------------------

_______________________

Задание 6
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice3.Part6
Входную информацию загружать из файла part6.txt
-------------------------------------------------------

Задание должно быть решено с помощью регулярных выражений без использования контейнерных классов.

Вход: текст (может состоять из латиницы и кириллицы, не содержит _).
Выход: исходный текст, но все повторяющиеся слова предварить знаком подчеркивания _

Словом считать последовательность содержащую только буквы (все остальные символы в состав слова не входят).
Создать статический метод convert, который преобразовывает вход в выход.

Заглушка метода
-------------------------------------------------------
public static String convert(String input) {
    ...
}
-------------------------------------------------------

Пример Input data
-------------------------------------------------------
This is a test
And this is also a test
And these are also tests
test
Это тест
Это также тест
И это также тесты
-------------------------------------------------------

Пример Output
-------------------------------------------------------
This _is _a _test
_And this _is _also _a _test
_And these are _also tests
_test
_Это _тест
_Это _также _тест
И это _также тесты
-------------------------------------------------------

_______________________	
	
Как получить входную информацию (файл должен находится в корне проекта, кодировка файла - Cp1251)
-------------------------------------------------------
package ua.nure.your_last_name.practice3;
 
import java.io.IOException;
import java.nio.file.*;
 
public class Util {
     
    private static final String ENCODING = "Cp1251";
 
    public static String readFile(String path) {
        String res = null;
        try {
            byte[] bytes = Files.readAllBytes(Paths.get(path));
            res = new String(bytes, ENCODING);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
        return res;
    }
 
    public static void main(String[] args) {
        System.out.println(readFile("part1.txt"));
    }
 
}


Практическое занятие №4
_______________________

Замечания.
1. Если приложение считывает информацию из файла, то необходимо указать кодировку, в которой она записана. Использовать кодировку Cp1251.
2. Если явно не указан язык, на котором записана входная текстовая информация, то использовать текст на языке, который содержит кириллицу (русский, украинский языки) и латиницу (английский язык).
3. В корневом пакете создать класс Demo, который демонстрирует работу всего написанного функционала.
4. Имена входных и выходных файлов указаны относительно значения системного свойства user.dir (совпадает с корневым каталогом проекта).
5. Обязательно посмотреть в лог сборки проекта (Jenkins), вывод должен совпадать с тем выводом, который получается на вашей локальной машине.
6. При выводе информации используйте ограничитель строки, получаемый динамически (System.lineSeparator).
7. Не используйте абсолютные адреса файлов, задавайте относительные пути от корня проекта, иначе проект не будет собран.
8. Timeoute сборки проекта в Jenkins 2 минуты. Если при сборке проекта будет вызвана функциональность ожидания консольного ввода, то максимум через 2 минуты проект будет снят с выполнения, а сама сборка помечена как Aborted.
9. Если Jenkins не собирает проект по причине выброса IllegalAccessError с сообщением "tried to access class XXX" поставьте уровень доступа типа с именем XXX в public.

_______________________

Задание 1
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice4.Part1
Входную информацию загружать из файла part1.txt
-------------------------------------------------------

Создать класс, который выводит содержимое текстового файла в консоль, инвертируя регистр всех символов каждого слова, которое содержит более 3 символов.
Файл брать размером не более 1 Кб (достаточно несколько строк).
Под словом понимать непрерывную последовательность символов латиницы или кириллицы.

_______________________

Задание 2
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice4.Part2
Входную информацию загружать из файла part2.txt
Выходную информацию загружать в файл part2_sorted.txt
-------------------------------------------------------

Создать класс, который создает и заполняет файл part2.txt случайными целыми числами от 0 до 50 (всего 10 чисел), затем читает файл и выводит его содержимое в другой файл part2_sorted.txt, отсортировав числа по возрастанию.
Файл part2.txt создавать только если он не существует. 
Содержимое обоих файлов (числа разделенные пробелом) вывести в консоль.

Для сортировки написать собственный метод, который осуществляет сортировку некоторым алгоритмом (например "пузырьком"). Выходной файл должен быть текстовым (читабельным).
Вывести содержимое входного и выходного файла в консоль.

Пример консольного вывода
-------------------------------------------------------
input  ==> 30 23 16 16 9 23 3 18 21 29
output ==> 3 9 16 16 18 21 23 23 29 30
-------------------------------------------------------

_______________________

Задание 3
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice4.Part3
Входную информацию загружать из файла part3.txt
-------------------------------------------------------

Файл содержит символы, слова, целые числа и числа с плавающей точкой. Написать класс, который имеет следующую функциональность: в цикле пользователь вводит тип данных (один из: char, String, int, double), в ответ приложение печатает в консоль все значения соответствующих типов, которые существуют в файле.
Если таких значений нет, то приложение должно печать сообщение "No such values"
Если пользователь вводит слово stop, то происходит выход из цикла.
Если пользователь вводит что-либо отличное от String, int, double, stop, то приложение должно печатать сообщение "Incorrect input".

Задачу решить с использованием регулярных выражений.

Замечание: под строкой понимать последовательность символов два и более. Символы - латинские или кириллические буквы в верхнем или нижнем регистре (обязательно предусмотреть наличие кириллицы во входном файле).

Пример исходного файла:
-------------------------------------------------------
a bcd 43.43 432 
и л фыва 89 .98
-------------------------------------------------------

Пример содержимого консоли:
-------------------------------------------------------
char<Enter>
a и л 
String<Enter>
bcd фвыа 
string<Enter>
Incorrect input
int<Enter>
432 89 
double<Enter>
43.43 .98 
stop<Enter>
-------------------------------------------------------

_______________________

Задание 4
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice4.Part4
Входную информацию загружать из файла part4.txt
-------------------------------------------------------

Создать класс, который реализует интерфейс java.lang.Iterable<String>. Класс должен разбирать текстовый файл и возвращать предложения из файла. Метод iterator данного класса должен возвращать объект итератор - экземпляр внутреннего класса. Метод Iterator#remove должен бросать исключение UnsupportedOperationException.

Не допускается использовать существующие реализации итераторов из контейнерных классов!

Замечание. Напишите регулярное выражение, которое "вырезает" предложения из текста, далее используйте объект Matcher при реализации методов интерфейса Iterator.

_______________________

Задание 5
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice4.Part5
Входной пакет ресурсов, локаль ru: resources_ru.properties
Входной пакет ресурсов, локаль en: resources_en.properties
Пакеты ресурсов расположить непосредственно в каталоге src
-------------------------------------------------------

Создать пакеты ресурсов (properties файлы) для двух локалей: ru и en. Пакеты содержат как минимум две записи.

Пример содержимого resources_en.properties
-------------------------------------------------------
table = table
apple = apple
-------------------------------------------------------

Пример содержимого resources_ru.properties
-------------------------------------------------------
table = стол
apple = яблоко
-------------------------------------------------------

Написать класс, который в цикле читает с консоли ключ (key) и имя локализации через пробел, в ответ печатает соответствующее значение в консоль. Признаком окончания ввода служит слово stop.

Если по введенной локали и ключу значение не может быть получено, то приложение должно печатать сообщение: "No such value".

Чтение из консоли и запись в консоль являются обязательными!

Пример содержимого консоли:
-------------------------------------------------------
table ru<Enter>
стол
table en<Enter>
table
asdf en<Enter>
No such values
apple ru<Enter>
яблоко
apple en<Enter>
apple
asdf en<Enter>
No such values
stop<Enter>
-------------------------------------------------------

_______________________

Задание 6
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice4.Part6
Входной файл part6.txt
-------------------------------------------------------

Файл содержит слова, записанные кириллицей и латиницей.
Написать класс, который имеет следующую функциональность.
Если пользователь вводит в консоли
1) Latn (или latn) - приложение печатает в консоль все слова, записанные с применением латиницы;
2) Cyrl (или cyrl) - приложение печатает в консоль все слова, записанные с применением кириллицы;
3) Stop (или stop) - приложение завершает свою работу;
4) любой другой ввод влечет появление сообщения Incorrect input


Пример входного файла:
-------------------------------------------------------
Is there anybody going to listen to my story
Лягає день. Він віддає свої надії ночі.
С барабаном ходит ёжик. Бум-бум-бум.
-------------------------------------------------------

Пример содержимого консоли:
-------------------------------------------------------
asdf<Enter>
asdf: Incorrect input
Latn<Enter>
Latn: Is there anybody going to listen to my story
Cyrl<Enter>
Cyrl: Лягає день Він віддає свої надії ночі С барабаном ходит ёжик Бум бум бум
latn<Enter>
latn: Is there anybody going to listen to my story
Stop
-------------------------------------------------------
_______________________

Содержимое класса Demo

В корневом пакете (ua.nure.your_last_name.practice4) должен находится класс Demo, который демонстрирует работу всего функционала.
Для тех подзадач, которые требуют ввода с консоли, переназначить стандартный поток ввода таким образом, чтобы ввод осуществлялся из некоторой заданной строки (после отрабатывания вашего кода необходимо предусмотреть восстановление стандартных потоков).

Demo.main должен отрабатывать без участия пользователя, никакого ожидания ввода с консоли при выполнении данного метода быть не должно. Пример переназначений см. в заглушке.

Если приложение на стенде зависнет в ожидании ввода с консоли, то не более чем через 2 минуты оно будет снято с выполнение (на все задачи выставлен timeout).

Пример метода Demo.main
-------------------------------------------------------
package ua.nure.your_last_name.practice4;

import java.io.*;
import ua.nure.your_last_name.practice4.*;

public class Demo {
    private static final InputStream STD_IN = System.in;

    public static void main(String[] args) {
        System.out.println("=========================== PART1");
        Part1.main(args);

        System.out.println("=========================== PART2");
        Part2.main(args);

        System.out.println("=========================== PART3");
        // set the mock input
        System.setIn(new ByteArrayInputStream(
                "char^String^int^double^stop".replace("^", System.lineSeparator()).getBytes()));
        Part3.main(args);
        // restore the standard input
        System.setIn(STD_IN);

        System.out.println("=========================== PART4");
        Part4.main(args);

        System.out.println("=========================== PART5");
        // set the mock input
        System.setIn(new ByteArrayInputStream(
                "table ru^table en^apple ru^stop".replace("^", System.lineSeparator()).getBytes()));
        Part5.main(args);
        // restore the standard input
        System.setIn(STD_IN);
		
	    System.out.println("=========================== PART6");
        // set the mock input
        System.setIn(new ByteArrayInputStream(
                "Latn^Cyrl^asdf^latn^cyrl^stop".replace("^", System.lineSeparator()).getBytes()));
        Part6.main(args);
        // restore the standard input
        System.setIn(STD_IN);
    }
}
-------------------------------------------------------


Практическое занятие №5
_______________________

Замечания.

(1) В Jenkins время сборки проекта ограничено 2 (двумя) минутами. По истечение этого времени задача будет снята с выполнения.

Console Output
-------------------------------------------------------
Build timed out (after 2 minutes). Marking the build as aborted.
Build was aborted
Finished: ABORTED
-------------------------------------------------------

(2) В корневом пакете должен находится класс Demo, который демонстрирует функциональность всех подзадач (его будет вызывать Jenkins).

(3) Для решения каждой подзадачи X будет гарантированно использованно несколько потоков:
  * поток, который выполняет метод PartX.main (это тот же самый поток, который выполняет Demo.main);
  * некоторое количество дочерних потоков.
Завершайте выполнение дочерних потоков ДО ТОГО, как будет завершен метод PartX.main (это нужно для тестов, который запускает Jenkins).

_______________________

Задание 1
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part1
-------------------------------------------------------

Создать дочерний поток, который бы в течение примерно 1 сек печатал свое имя каждые треть секунды.
Сделать это тремя способами:
  * при помощи расширения класса Thread;
  * при помощи реализации интерфейса Runnable.
  * с использованием ссылки на статический метод, который реализует заданную функциональность.
  
Продемонстрировать работу всех трех вариантов. Выполнение должно быть последовательным.
Вначале отрабатывает одна реализация, потом вторая, затем третья.

_______________________

Задание 2
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Spam
-------------------------------------------------------

Создать класс Spam, который получает в конструкторе массив сообщений и согласованный с ним массив интервалов времени в миллисекундах и выводит одновременно соответствующие сообщения на экран через заданные интервалы времени. По нажатию на Enter приложение должно завершать свою работу (данную функциональность поместить в метод Spam.main).

Рекомендуемая структура класса Spam:
-------------------------------------------------------
public class Spam {
	private Thread[] threads;
	public Spam(String[], int[]) {...}
	public void start() {...}
	public void stop() {...}
	private static class Worker extends Thread {...}
	public static void main(String[] args) {...}
-------------------------------------------------------

Входные данные (массив сообщений и массив пауз) записывать в коде класса Spam. Количество элементов в каждом из массивов - минимум 2, их можно взять из примера (см. код ниже).

Пример входной информации:
-------------------------------------------------------
String[] messages = new String[] { "@@@", "bbbbbbb" };
int[] times = new int[] { 333, 222 };
-------------------------------------------------------

В методе Part2.main смоделировать ввод Enter через 2 сек.

Алгоритм моделирования консольного ввода (метод Part2.main):
-------------------------------------------------------
a) подменить системный поток ввода на свой собственный
   System.setIn(YOUR_OWN_INPUT_STREAM);
 
b) в отдельном потоке вызвать Spam.main
   Thread t = new Thread() { public void run() {Spam.main(null);}};
   t.start();
 
c) дождаться завершения Spam.main
   t.join();
 
d) восстановить системный поток
   System.setIn(CAСHED_VALUE_OF_SYSTEM_IN)
-------------------------------------------------------

(4) Для реализации своего собственного потока ввода целесообразно создать класс, который расширяет абстрактный класс java.io.InputStream. При этом придется реализовать единственный абстрактный метод этого класса:

-------------------------------------------------------
public abstract int read() throws IOException;
-------------------------------------------------------

Все методы класса InputStream (а также всех его наследников), которые читают байты из источника информации, в конечном счете вызывают метод read. Достаточно реализовать паузу в этом методе при первом его вызове, которая заставит поток выполнения, который вызвал метод read, ожидать. Метод read должен последовательно возвращать байты, которые соответствуют ограничителю строки, после чего постоянно возвращать -1 (признак того, что информации во входном потоке больше нет).

_______________________

Задание 3
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part3
-------------------------------------------------------

Создать класс со следующим содержимым:
-------------------------------------------------------
public class Part3 {
	private int counter;
	private int counter2;
	
	private Thread[] threads;
	...
	
	public Part3(int n, int k, int t) { ...	}
	
	public void reset() { ... }	
	public void test() { ... }
	public void testSync() { ... }	
	
	public static void main(String[] args) {
		Part3 p = new Part3(3, 5, 100);
		p.test();
		p.reset();
		p.testSync();
	}	
}
-------------------------------------------------------

Метод test запускает на выполнение n дочерних потоков, каждый из которых в цикле повторяет k раз следующее:
  * печатает значения счетчиков counter и counter2 через пробел;
  * увеличивает первый счетчик counter на единицу;
  * засыпает на t мсек;
  * увеличивает второй счетчик counter2 на единицу.

Метод testSync делает то же самое, что и test, но содержимое цикла подвергнуто синхронизации.

Реализовать следующую схему (см. метод Part3.main):
  * отрабатывает не синхронизированный вариант (test);
  * отрабатывает синхронизированный вариант (testSync).

Замечания.
1) перед тем, как начнет работу синхронизированный вариант, сборосьте значения счетчиков в 0 (reset);
2) для вывода в стандартный поток вывода используйте метод PrintStream#printf:
-------------------------------------------------------
System.out.printf("%s %s%n", counter, counter2);
-------------------------------------------------------

_______________________

Задание 4
-------------------------------------------------------
Название класса: ua.nure.your_last_name.Practice5.Part4
Входную информацию загружать из файла part4.txt
-------------------------------------------------------

Распараллелить задачу поиска максимального значения в матрице целых чисел MxN (загружать из файла) при помощи M потоков. Дополнительно решить задачу поиска максимального значения без распараллеливания. Вывести результат и время выполнения кода (в миллисекундах) для обоих вариантов.
	
В обязательном порядке в обоих вариантах каждую операцию сравнения снабдить задержкой в 1 мс!

Придерживаться следующего формата вывода:
-------------------------------------------------------
MAX
TIME
MAX2
TIME2
-------------------------------------------------------

где MAX, TIME - максимальное значение и время поиска при многопоточном решении задачи; MAX2, TIME2 - максимальное значение и время поиска в однопоточном варианте.
	
Работу приложения проверить на матрице 4x100 случайных чисел.

Содержимое файла part4.txt должно представлять из себя читабельную матрицу, числа разделены пробелами, строки разделены ограничителем строки.

Замечания.

(1) Ограничитель строки должен быть платформонезависимым (учитывать это при чтении информации).

(2) Входной файл part4.txt создать любым удобным для вас способом до запуска Part4.main (например, с помощью какого-нибудь вспомогательного класса). Приложение (Part4.main) файл part4.txt не создает и содержимое его не модифицирует, размерность матрицы определять по содержимому part4.txt

Пример содержимого part4.txt для M=5, N=20
-------------------------------------------------------
706 575 855 882 595 778 477 602 147 467 693 793 120 384 256 866 548 367 910 848
206 232 632 315 743 823 620 111 279 548 210 393 791 815 519 768 168 484 780 705
709 127 900 171 189 590 563 317 600 975 892 296 166 353 863 312 399 872 964 591
302 869 679 157 419 485 325 290 739 149 407 648 688 474 311 177 318 611 348 557
559 283 171 352 698 759 384 822 598 410 802 293 962 859 812 153 436 392 869 167
-------------------------------------------------------

Пример вывода результата
-------------------------------------------------------
975
26
975
115
-------------------------------------------------------
	
Для входных данны3 M=4, N=100 время распараллеленного поиска должно быть примерно в 4 раза меньше, чем время поиска в однопоточном варианте.

_______________________

Задание 5
-------------------------------------------------------
Название класса: ua.nure.your_last_name.Practice5.Part5
Выходную информацию записывать в файл part5.txt
-------------------------------------------------------

Создать k потоков, которые одновременно пишут в один и тот же файл символы:

-------------------------------------------------------
первый поток записывает цифру 0 ровно 20 раз на 1й строке файла;
второй поток записывает цифру 1 ровно 20 раз на 2й строке файла;
...
десятый поток записывает цифру 9 ровно 20 раз на 10й строке файла.
-------------------------------------------------------

Требования к реализации.
(1) В обязательном порядке запись каждой цифры снабдить паузой в 1 мс!
(2) Для записи использовать класс RandomAccessFile.
(3) Допускается использование не более одного объекта класса RandomAccessFile!
(4) Перед началом работы файл в который будет происходить запись должен быть удален, если он существует.
(5) Главный поток, после запуска дочерних потоков на выполнение, должен дождаться их завершения, после чего вывести в консоль содержимое файла.

Замечания.
(1) Метод RandomAccessFile#seek(long) позволяет передвигать указатель внутри файла. Каждый поток должен знать в каком месте файла ему записывать информацию. Так как в условии фигурирует термин "строка", следует вывод каждого потока завершать ограничителем строки, который выводить кросс-платформенным образом.
(2) Для того, чтобы записать некоторую цифру можно использовать выражение '0'+ n, где n - цифра от 0 до 9 включительно.
Передвижение указателя внутри файла и запись информации необходимо синхронизировать.

Результат работы приложения
-------------------------------------------------------
00000000000000000000
11111111111111111111
22222222222222222222
33333333333333333333
44444444444444444444
55555555555555555555
66666666666666666666
77777777777777777777
88888888888888888888
99999999999999999999
-------------------------------------------------------

_______________________

Задание 6
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part6
-------------------------------------------------------

В главном потоке создать и запустить на выполнение дочерний поток.
Последовательно перевести и распечатать состояние дочернего потока (возможно через промежуточные состояния) в:
BLOCKED, WAITING, TERMINATED

Замечания.
1) метод Thread.sleep не использовать;
2) допускается использовать только один монитор синхронизации (см. код ниже).
3) многократный запуск приложения на выполнение должен генерировать один и тот же результат.
4) перед решение задачи целесообразно ознакомится с примером, кот. находится на GDocs диске по адресу:
Lectures/Module08/code/Lecture-2019-05-20.zip!/State/src/Test.java

Заглушка класса Part6:
-------------------------------------------------------
public class Part6 {

	private static final Object M = new Object();

	public static void main(String[] args) throws InterruptedException {
		Thread t = new Thread() {
			public void run() {
				// place your code here
			}
		};

		// place your code here
	}
}
-------------------------------------------------------

Результат выводимый в консоль:
-------------------------------------------------------
BLOCKED
WAITING
TERMINATED
-------------------------------------------------------


Практическое задание №6
_______________________

Замечания.

(1) Везде в коде, при реализации функциональных интерфейсов использовать лямбда выражения или ссылки на методы.

(2) Помните, что контейнеры HashSet/ТгееSet не контролируют потенциальное появление дубликатов при изменении состояния объектов, которые в них хранятся, то же касается и ключей контейнеров HashMap/ТгееМар.

(3) В задании 6 под словом понимать непрерывную последовательность букв латинского алфавита.
_______________________


Задание 1
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part1
Классы:
Part1 - содержит моделирование консольного ввода/вывода и вызов метода WordContainer.main
WordContainer - содержит требуемую по условию функциональность
Word - поставлен в соответствие сущности 'слово с информацией о его частоте в тексте'.
-------------------------------------------------------

Разработать приложение, которое считывает текст из консольного ввода и выводит слова в порядке убывания частоты их появления в тексте (при совпадении частот порядок - лексикографичеcкий).
Под словами понимать непрерывную последовательность непробельных символов.

Решить задачу с применением ООП подхода.

Класс Word, содержит строковое поле content и целое поле frequency, контейнер WordContainer агрегирует объекты Word.

При использовании контейнерных классов из ядра грамотно реализовать (если они будут нужны) методы Word#equals / Word#hashCode / Word#compareTo.

При запуске WordContainer.main осуществляет чтение из стандартного потока ввода (консоли). Консольный ввод в общем случае может содержать несколько строк, в каждой строке может быть несколько слов. Признаком завершения консольного ввода служит слово stop.

Продемонстрировать работу приложения (Part1.main).

Пример входной информации
-------------------------------------------------------
asd 43 asdf asd 43
434 asdf
kasdf asdf stop asdf
stop
-------------------------------------------------------

Пример выходной информации
-------------------------------------------------------
asdf : 3
43 : 2
asd : 2
434 : 1
kasdf : 1
-------------------------------------------------------
_______________________


Задание 2
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part2
Название класса: Part2
-------------------------------------------------------

Написать программу, которая моделирует следующий процесс.

В кругу стоят n человек, пронумерованных от 0 до n-1.
При ведении счета по кругу вычеркивается каждый k-й человек (0>k>n), пока не останется один.

Пример для n=7 и k=3.
Начальное состояние:
0123456
Итерации:
013456
01346
0346
034	
03
3

Решить задачу двумя способами:

1) при помощи удаления элемента по индексу самим контейнером [List#remove(int)]
-------------------------------------------------------
// метод возвращает время работы
public static long removeByIndex(List>Integer> list, int k) {}
-------------------------------------------------------

2) при помощи удаления элемента с помощью итератора [Iterator#remove()]
-------------------------------------------------------
// метод возвращает время работы
public static long removeByIterator(List>Integer> list, int k) {}
-------------------------------------------------------

Сравнить время работы каждого способа на одинаковых входных данных (задавать в Part2.main) с использованием объектов ArrayList и LinkedList.
В качестве входных данных использовать n=10000, k=4.

Продемонстрировать работу приложения (Part2.main)

Пример выходной информации (придерживаться данного формата).
-------------------------------------------------------
ArrayList#Index: 13 ms
LinkedList#Index: 93 ms
ArrayList#Iterator: 20 ms
LinkedList#Iterator: 15 ms
-------------------------------------------------------
_______________________


Задание 3
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part3
Названия классов: Part3, Parking
-------------------------------------------------------

Реализовать класс Parking, моделирующий работу n-местной автостоянки.

Машина подъезжает к определенному месту k (0 >= k > n) и, если оно не занято, занимает его.
Если место k занято, то едет вправо, пока не встретит свободное место.
Если свободного места вплоть до конца стоянки нет, то поиск свободного места осуществляется с начала стоянки.
Если все места заняты, то состояние стоянки не меняется (машина уезжает).
Данную функциональность реализовать в методе:
-------------------------------------------------------
// Метод возвращает true, если машину удалось поставить на стоянку
boolean arrive(int k)
-------------------------------------------------------

Дополнительно реализовать метод, моделирующий отъезд машины:
-------------------------------------------------------
// Метод возвращает true, если в позиции k находилась машина
boolean depart(int k)
-------------------------------------------------------

Методы бросает исключение IllegalArgumentException, если k находится вне диапазона [0, n-1].

Также реализовать метод, который распечатывает текущее состояние стоянки:
-------------------------------------------------------
void print()
-------------------------------------------------------

Обозначать нулем пустое место; единицей - занятое место.

Пример для n=4.
Начальное состояние стоянки: 0000

Состояние стоянки после выполнения методов (справа после запятой значение, возвращаемое методами):
-------------------------------------------------------
parking.arrive(2)  // 0010, true
parking.arrive(3)  // 0011, true
parking.arrive(2)  // 1011, true
parking.arrive(2)  // 1111, true
parking.arrive(2)  // 1111, false
parking.depart(1)  // 1011, true
parking.depart(1)  // 1011, false
-------------------------------------------------------

Продемонстрировать работу приложения (Part3.main).
_______________________


Задание 4
-------------------------------------------------------
Имя пакета: ua.nure.your_last_name.practice6.part4
Названия классов: Part4, Range
-------------------------------------------------------

Написать класс Range, который бы представлял собой промежуток чисел [n, m], где n > m.
Класс должен реализовывать интерфейс Iterable.
Итератор реализовать таким образом, чтобы он проходил он начала до конца промежутка.
В конструктор передавать дополнительный параметр reverse.

Класс Range должен иметь два конструктора:
-------------------------------------------------------
public Range(int n, int m) { ... }
public Range(int n, int m, boolean reverse) { ... }
-------------------------------------------------------

Пример:
-------------------------------------------------------
Range range = new Range(3, 10);
for (Integer el : range) {
	System.out.printf("%d ", el);
}
System.out.println();
// result: 3 4 5 6 7 8 9 10
 
range = new Range(3, 10, true);
for (Integer el : range) {
	System.out.printf("%d ", el);
}
System.out.println();
// result: 10 9 8 7 6 5 4 3
-------------------------------------------------------

Контейнерные классы не использовать.

Продемонстрировать работу приложения (Part4.main).
_______________________


Задание 5
-------------------------------------------------------
Название класса: ua.nure.your_last_name.task4.Part5
Названия классов: Part5, Tree
-------------------------------------------------------

Создать generic класс Tree, который реализует структуру данных "двоичное дерево поиска".
Контейнерные классы не использовать.

Элементы класса Tree, обязательные к реализации:
-------------------------------------------------------
public class Tree>E extends Comparable>E>> {
	// добавляет элемент в контейнер
	// если в контейнере есть элемент равный по compareTo добавляемому,
	// то добавления не происходит и метод возвращает false
	// в противном случае элемент попадает в контейнер и метод возвращает true
	// первый добавляемый элемент становится корнем дерева
	// автобалансировки в дереве нет
	public boolean add(E element) {...}
 
	// добавляет все элементы из массива в контейнер (вызов в цикле метода add, см. выше)
	public void add(E[] elements) {...}
 
    // удаляет элемент из контейнера
	// если удаляемого элемента в контейнере нет, то возвращает false
	// в противном случае удаляет элемент и возвращает true
	// ВАЖНО! при удалении элемента дерево не должно потерять свойства бинарного дерева поиска
	public boolean remove(E element) {...}
 
	// распечатывает дерево, так чтобы было видно его древовидную структуру, см. ниже пример
	public void print() {...}
 
	// вложенный класс, объекты этого класса составляют дерево
	private static class Node>E> {...}
}
-------------------------------------------------------

Результат вывода Part5.main (отступ 2 пробела):
-------------------------------------------------------
true
false
~~~~~~~
    0
  1
    2
3
    4
  5
    6
~~~~~~~
true
false
~~~~~~~
    0
  1
    2
3
    4
  6  
-------------------------------------------------------

Продемонстрировать работу приложения (Part5.main).

При удалении элемента придерживаться следующего алгоритма.
1. Если у узла нет дочерних узлов, то у его родителя нужно заменить соответствующий указатель на null.
2. Если у узла есть только один дочерний узел, то нужно создать новую связь между родителем удаляемого узла и его дочерним узлом.
3. Если у узла два дочерних узла, то нужно 
3.1. найти следующий за ним элемент (у этого элемента не будет правого потомка)
3.2. его левого потомка подвесить на место найденного элемента
3.3. удаляемый узел заменить найденным узлом.

Визуальное изображение алгоритма (на картинке дерево "перевернуто"): algorithm.png
_______________________


Задание 6
-------------------------------------------------------
Пакет: ua.nure.your_last_name.practice6.part6
Класс: Part6 (принимает параметры командной строки)
Входную информацию загружать из файла part6.txt (должен находится в корне проекта)
-------------------------------------------------------

Реализовать консольное приложение (Part6) которое анализирует текст.

Формат входных параметров командной строки для приложения (программа должна понимать как короткие, так и длинные опции):
-------------------------------------------------------
-i (или --input) путь к входному файлу;
-t (или --task) наименование подзадачи.
-------------------------------------------------------

Всего параметров командной строки 4, т.е. две пары >имя_опции значение_опции>.
Порядок следования опций с их значениями прооизвольный.

Примеры параметров командной строки для запуска приложения:
-------------------------------------------------------
-i input.txt -t frequency
--input input.txt --task length
-------------------------------------------------------

В методе Demo.main смоделировать передачу параметров командной строки в метод Part6.main:
-------------------------------------------------------
System.out.println("~~~~~~~~~~~~Part6");
Part6.main(new String[] {"--input", "part6.txt", "--task", "frequency"});
Part6.main(new String[] {"--input", "part6.txt", "--task", "length"});
Part6.main(new String[] {"--input", "part6.txt", "--task", "duplicates"});
-------------------------------------------------------

Подзадач всего три: frequency, length, duplicates.

Подзадача Part 1 (frequency)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.Part61
-------------------------------------------------------

Во входном файле найти три слова, которые встречаются наиболее часто (при совпадении частот – те, которые встречаются раньше), и распечатать их отсортированными по алфавиту в обратном порядке, в формате: слово ==> частота

Пример вывода:
-------------------------------------------------------
panda ==> 15
ezhik ==> 20
apple ==> 19
-------------------------------------------------------

Подзадача Part 2 (length)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.part6.Part62
-------------------------------------------------------

Во входном файле найти три самых длинных слова и распечатать их в формате: слово ==> количество букв в слове. Список должен быть отсортирован по убыванию количества букв в слове.

Если у двух слов количество букв совпадает, то слово, которое было в исходном файле раньше, должно в результирующем списке находиться также раньше.

Пример вывода:
-------------------------------------------------------
anesthetist ==> 11
kitchen ==> 7
bird ==> 4
-------------------------------------------------------

Подзадача Part 3 (duplicates)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.part6.Part63
-------------------------------------------------------

Во входном файле найти первые три слова, которые имеют дубликаты, и напечатать их инверсию в верхнем регистре.

Пример вывода
-------------------------------------------------------
ADNAP
TAC
ENIGREBUA
-------------------------------------------------------

Практическое задание №7
_______________________

Замечание.
1. Формулировка бизнес области поставлена каждому в Jenkins индивидуально.
2. Пример решения аналогичной задачи можно найти на google disc-e.

_______________________

Задание сформулировано следующим образом.

1. Создать файл XML (input.xml) и соответствующую ему схему XSD (input.xsd).

2. При разработке XSD обязательно использовать: 
простые и составные типы, перечисления, шаблоны и предельные значения.

3. Создать Java-класс, соответствующий данному описанию.

4. Создать Java-приложение (назвать Main) для разбора XML-документа и 
инициализации контейнера объектов информацией из XML-файла. 
Для разбора использовать: SAX, StAX парсеры, а также DOM анализатор (все три варианта).

5. Определить методы, которые будут сортировать объекты контейнера 
с использованием интерфейса Comparator по некоторому параметру или набору параметров 
(три парсера => три варианта сортировки => три метода).

6. Произвести проверку XML-документа на валидность относительно XSD 
(с помощью валидирующего парсера или validation API).

7. Определить метод сохранения информации из контейнера в XML-документ.

8. Продемонстрировать работу приложения:
a) каждым из парсеров прочитать XML-документ;
b) получить контейнер объектов;
c) отсортировать объекты в контейнере (одним из трех способов);
d) сохранить отсортированный контейнер в XML-документ (в файл).

9. Входными данными приложения являются имена двух файлов: 
XML-документа и XSD-документа; 
выходными данными - три XML файла. 
Имена входных файлов задавать параметрами командной строки 
(два параметра или один, если валидирование будет происходить относительно схемы, 
заданной внутри XML-документа).

10. Для демонстрации работы приложения создать класс Demo, 
который вызывает метод Main.main вашего приложения с соответствующим значением 
параметров командной строки:

Demo.java
-------------------------------------------------------
package ua.nure.your_last_name.practice7;
/**
 * Demo class to run project WO command line.
 */
class Demo {
    public static void main(String[] args) throws Exception {
        Main.main(new String[] { "input.xml" });
    }
}
-------------------------------------------------------

11. Классы верхнего уровня и нетривиальные методы должны быть документированы.

12. Опционально. Создать XSL документ преобразующий XML-документ в документ HTML.

_______________________

Соглашение об именованиях

Корневой элемент XML документа назвать согласно названию задачи или 
исходя из того что это контейнер однотипных элементов, имя которого указано в задаче.

Пример: если задача называется Тестирование, а элемент имеет имя Test,
то корневой элемент можно назвать либо Testing либо Tests.

Входные и выходные файлы должны иметь следующие имена.

Входные файлы:
-------------------------------------------------------
input.xml - XML-документ, валидный относительно input.xsd
input.xsd - XSD-докумен, схема для input.xml
-------------------------------------------------------

Выходные файлы (результат):
-------------------------------------------------------
output.dom.xml - результат работы DOM-анализатора и последующей сортировки одним из трех способов.
output.sax.xml - результат работы SAX-парсера и последующей сортировки одним из трех способов.
output.stax.xml - результат работы StAX-парсера после сортировки одним из трех способов. 
-------------------------------------------------------

Замечание.

1. input.xsd должен декларировать целевое пространство имен (атрибут targetNamespace должен присутствовать).

2. input.xml должен быть валидным относительно input.xsd

3. Выходные XML документы output.dom.xml, output.sax.xml и output.stax.xml должны быть валидны 
относительно исходной XML схемы input.xsd, если из нее исключить декларирование целевого пространства имен 
(см. файл input-no-targetNamespace.xsd в проекте-примере).

(Замечание: выходные XML документы не обязаны объявлять атрибут noNamespaceSchemaLocation)

Пример проекта см. Goggle Disc: Module10/Practice7Example.zip


Практическое задание №8
_______________________

Замечание.

1. Класс User должен содержать:
1) метод 'getLogin()', который возвращает логин пользователя;
2) метод 'toString()', который возвращает логин пользователя;
3) реализацию метода 'equals(Object)', согласно которой два объекта User равны тогда и только тогда, когда они имеют один логин.

2. Класс Team должен содержать:
1) метод 'getName()', который возвращает название группы;
2) метод 'toString()', который возвращает название группы;
3) реализацию метода 'equals(Object)', согласно которой два объекта Team равны тогда и только тогда, когда они имеют одно название.

3. Соединение получать с помощью вызова метода 'DriverManager.getConnection(CONNECTION_URL)'.
CONNECTION_URL - строка соединения, включающая логин и пароль пользователя.
Строку соединения читать из файла 'app.properties' по ключу 'connection.url'.
Файл расположить в корне проекта.

Пример содержимого файла app.properties:
-------------------------------------------------------
connection.url = jdbc:mysql://localhost:3306/p8db?user=user&password=userpass
-------------------------------------------------------

Замечание. Класса драйвера вручную не загружать (речь идет о вызове 'Class.forName(JDBC-DRIVER-FQN)', подобного рода строки исключить из кода).

4. Метод 'setTeamsForUser(User, Team...)' реализовать с помощью транзакции: вследствие вызова данного метода пользователю будут назначены либо все группы, либо ни одной.
Если метод будет вызван так: setTeamsForUser(user, teamA, teamB, teamC),
то в таблицу связей 'users_teams' записи должны быть вставлены последовательно в порядке появления групп в списке аргументов слева направа:

user_id, teamA_id
user_id, teamB_id 
user_id, teamC_id

Если последняя запись не может быть добавлена, то первые две также не попадают в базу данных (rollback transaction).

При тестировании Jenkins будет использовать Apache Derby RDBMS.
Скрипт создания тестовой базы (для Derby): 
-------------------------------------------------------
CREATE TABLE users (
	id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
	login VARCHAR(10) UNIQUE
);
CREATE TABLE teams (
	id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
	name VARCHAR(10)
);
CREATE TABLE users_teams (
	user_id INT REFERENCES users(id) ON DELETE CASCADE,
	team_id INT REFERENCES teams(id) ON DELETE CASCADE,
	UNIQUE (user_id, team_id)
);
-------------------------------------------------------

5. Уточнение, метод DBManager#getUserTeams должен возвращать объект List<Team>.
______________________

База данных.

В качестве базы данных использовать любую реляционную БД.

БД содержит три таблицы:
users (id, login)
teams (id, name)
users_teams (user_id, team_id)

Изначально таблицы БД должны иметь некоторое наполнение (см. код класса Demo)

В корне создать каталог sql и сохранить в нем скрипт создания базы данных db-create.sql
_______________________


Класс Demo (скопировать в свой проект)
-------------------------------------------------------
package ua.nure.your_last_name.practice8;

import java.util.List;

import ua.nure.your_last_name.practice8.db.DBManager;
import ua.nure.your_last_name.practice8.db.entity.Team;
import ua.nure.your_last_name.practice8.db.entity.User;

public class Demo {

    private static void printList(List<?> list) {
        System.out.println(list);
    }

    public static void main(String[] args) {
        // users  ==> [ivanov]
        // teams ==> [teamA]

        DBManager dbManager = DBManager.getInstance();

        // Part 1
        dbManager.insertUser(User.createUser("petrov"));
        dbManager.insertUser(User.createUser("obama"));
        printList(dbManager.findAllUsers());
        // users  ==> [ivanov, petrov, obama]

        System.out.println("===========================");

        // Part 2
        dbManager.insertTeam(Team.createTeam("teamB"));
        dbManager.insertTeam(Team.createTeam("teamC"));

        printList(dbManager.findAllTeams());
        // teams ==> [teamA, teamB, teamC]

        System.out.println("===========================");

        // Part 3
        User userPetrov = dbManager.getUser("petrov");
        User userIvanov = dbManager.getUser("ivanov");
        User userObama = dbManager.getUser("obama");

        Team teamA = dbManager.getTeam("teamA");
        Team teamB = dbManager.getTeam("teamB");
        Team teamC = dbManager.getTeam("teamC");

        // method setTeamsForUser must implement transaction!
        dbManager.setTeamsForUser(userIvanov, teamA);
        dbManager.setTeamsForUser(userPetrov, teamA, teamB);
        dbManager.setTeamsForUser(userObama, teamA, teamB, teamC);

        for (User user : dbManager.findAllUsers()) {
            printList(dbManager.getUserTeams(user));
            System.out.println("~~~~~");
        }
        // teamA
        // teamA teamB
        // teamA teamB teamC

        System.out.println("===========================");

        // Part 4

        // on delete cascade!
        dbManager.deleteTeam(teamA);

        // Part 5
        teamC.setName("teamX");
        dbManager.updateTeam(teamC);
        printList(dbManager.findAllTeams());
        // teams ==> [teamB, teamX]

    }
}
-------------------------------------------------------

Во всех заданиях создать и реализовать соответствующие типы таким образом,
чтобы при запуске класса Demo отрабатывала соответствующая функциональность.

Задание 1
_______________________

Метод DBManager#insertUser должен модифицировать поле id объекта User.
Метод DBManager#findAllUsers возвращает объект java.util.List<User>.
_______________________


Задание 2
_______________________

Метод DBManager#insertTeam должен модифицировать поле id объекта Team.
Метод DBManager#findAllTeams возвращает объект java.util.List<Team>.
_______________________


Задание 3
_______________________

Метод DBManager#setTeamsForUser должен реализовывать транзакцию. Грамотно реализовать логику commit/rollback транзакции.
Метод DBManager#getUserTeams возвращает объект java.util.List<Team>.
_______________________


Задание 4
_______________________

Метод DBManager#deleteTeam удаляет группу по имени.
Все дочерние записи из таблицы users_teams также должны быть удалены.
Последнее реализовать с помощью каскадных ограничений ссылочной целостности:
ON DELETE CASCADE.
_______________________


Задание 5
_______________________

Метод DBManager#updateTeam обновляет группу.
_______________________